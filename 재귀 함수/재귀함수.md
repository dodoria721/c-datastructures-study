# 재귀 함수(Recursion)
**재귀 함수**는 정의된 함수 안에서 스스로를 다시 호출하는 방식으로 동작하는 함수를 말합니다. 이 특성을 이용하면 반복문을사용하지 않고도 복잡한 문제를 간결하게 해결할 수 있습니다.

## 재귀 함수의 기본적인 형태와 주의점
```
#include<stdio.h>

void Recursive()
{
  printf("재귀함수 호출\n");
  Recursive(); //탈출 조건이 없어 무한 호출
}

int main()
{
  Recursive();
  return 0;
}
```

제시된 코드처럼 재귀 함수를 정의할 경우, 함수는 탈출할 조건이 없어 무한히 자신을 호출한다. 이로 인해 프로그램은 다음과 같은 문제를 겪게된다.

1. **호출 스택(Call Stack)의 증가**: 함수가 호출될 때마다 해당 함수의 실행 정보를 담는 스택 프레임이 호출 스택에 하나씩 쌓인다. 무한 재귀에 빠지면 이 스택 프레임들이 계속해서 쌓여 메모리 공간을 모두 차지하게 된다.
2. **스택 오버플로(Stack Overflow)**: 프로그램에 할당되 호출 스택의 메모리 용량이 한계를 넘어서면, 스택 오버플로라는 오류가 생겨 프로그램이 강제 종료 된다.

따라서 재귀 함수를 안전하게 사용하려면, 무한 반복을 막기 위한 **탈출 조건**을 반드시 포함해야한다. 

## 재귀 함수의 올바른 사용 예시(팩토리얼)

탈출 조건을 포함한 재귀 함수를 팩토리얼 예시를 통해 구현해보겠다. 

일반적인 팩토리얼은 어떤 양의 정수 n이 존재할때 1부터 n까지의 숫자를 모두 곱한 값을 의미하며, n!로 표시한다. 식으로 표현하면 다음과 같다

$$n! = n * (n-1) * (n-2) * (n-3) * ... * 2 * 1$$
$$&downarrow;$$
$$n! = n * (n-1)1$$

위 식처럼 n 팩토리얼은 정수 n과 (n-1)팩토리얼의 곱으로 표현가능하다. 따라서 n!은 다음과 같이 정의 할 수 있다.

$$f(n) = \begin{cases}n \times f(n-1) & n \geq 1\\
          1 & n = 0\end{cases}$$

(n=0 일때 1인지는 여기서는 따로 다루진 않겠다) 위의 식을 토대로 재귀함수로 표현하면 다음과 같다.

```
int Factorial(int n) {
  if(n=0) return 1; //탈출 조건
  else return n*Factorial(n-1); //함수 호출
}
```
