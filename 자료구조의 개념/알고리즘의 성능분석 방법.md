# 알고리즘 성능분석 방법
잘 작동하는 자료구조와 알고리즘을 찾는 것이 목적이라면 자료구조에 맞는 알고리즘을 외워두기만 하면 된다. 하지만 우리는 잘 작동하는 것 뿐만 아니라 빠른 성능까지 원한다. 때문에 알고리즘을 분석하고 평가할 줄 알아야 한다.

### 알고리즘을 평가하는 두가지 요소
시간 복잡도(Time Complexity)와 공간 복잡도(Space Complexity)가 있다. 시간 복잡도는 **속도**와 관련있고, 공간 복잡도는 **메모리 사용량**과 관련이 있다.

메모리를 적게쓰면서 속도도 빠른 알고리즘이 좋은 것이 당연하다. 하지만 대부분의 사람들은 메모리의 사용량 보다 실행속도에 초점을 둔다. 따라서 앞으로 시간 복잡도에 대해 중점적으로 다루도록 하겠다.

### 알고리즘 시간 복잡도 함수 T(n)
그렇다면 '어떻게 속도를 평가하나요?' 라는 질문이 있을 수 있다. 이 질문에 대한 답으로써 알고리즘의 연산 횟수를 세라고 말하고 싶다.

일일이 그 많은 연산의 횟수를 다 세라는 것이 아니다. 연산에 있어서 핵심 연산을 파악을 해야 한다. 

```
for(i=0; i<len; i++){
  if(ar[i] == target)
    return i;
}
```
위의 코드는 순차탐색 알고리즘에서 발췌한것이다. 이 코드에서 사용된 연산자는 <, ++, == 이렇게 총 3가지가 있다.

== 비교 연산의 수가 적을 수록 <, ++ 연산의 수가 줄어 들고, 반대로 많을 수록 많아진다. 이것으로 <, ++ 의 연산자는 == 연산에 의존적임을 알 수 있다. 다시말해 **== 연산이 핵심 연산**이다.

비교연산이 얼마나 수행되었는지를 알면 그것을 토대로 함수(T(n))을 만들 수 있다.

하지만 운이 좋아서 처음에 바로 찾을 수도 있고, 찾고자 하는 숫자가 없어서 끝까지 봐야 하는 경우도 있다. 

여기서 우리가 주목할것은 가장 최악의 경우 Worst case를 따져봐야 한다. 데이터가 많아 질 수록 연산횟수에 따른 Worst case가 알고리즘별로 큰 차이를 보이기 때문이다.

위의 코드를 예시로 Worst case를 구해보면 내가 찾는 숫자가 배열에 없어서 끝까지 보는 상황이다. 이때 배열의 길이가 n 이기 때문에 n번의 비교연산을 해야하고 그것을 함수로 표현하면 
**T(n) = n** 으로 표현할 수 있다. 여기서는 가장 쉬운 예시를 들었지만 알고리즘따라 함수는 달라질 수 있다.

---
어쨋든 간에 더 좋은 성능을 내는 알고리즘을 찾아야 한다. 위에서 설명한 함수를 바탕으로 단순히 생각해 봤을때 n이 동일할때 T(n)이 작은것이 무조건 좋은것으로 생각할 수 있다.
하지만 이 또한 상황에 따라 다를 수 있다. 밑에 그래프를 보며 설명하겠다.

<img width="296" height="245" alt="Image" src="https://github.com/user-attachments/assets/33bfc4a1-0c29-4fcc-adae-02a1ce906d43" />

파란색 선(A), 빨간색 선(B) 동일한 n값을 가지고 있다. 이때 n 값이 증가할 수록 B가 기하급수 적으로 증가하는 모습을 볼 수 있다. 데이터가 많은 상황에서는 B 알고리즘 보다는 A를 사용하는 것이 효과적일 수 있다.

하지만 대체로 안정적인 성능을 내는 A 알고리즘은 구현 난위도가 어렵다. 따라서 데이터의 수가 그리 많지 않은 상황을 때는 A 알고리즘을 사용하는 것이 이득일 수 있다.

알고리즘에는 정답이 없다. 상황에 따라 종합적으로 생각해서 알고리즘을 선택하기 바란다.

### 빅-오 표기법
데이터의 수 n에 따른 시간 복잡도 함수 T(n)를 정확히 구하는 것은 사실상 쉽지 않다. 핵심 연산을 파악하는게 어려울 수 있고, 만약 파악했다고 하더라도 계산과정에서 오차가 있을 수 있다.

만약 한 알고리즘의 시간 복잡도 함수 T(n)을 계산했을 때 $n^2+n+1$ 아니면 $n^2+2n+1$ 함수가 나왔다. 둘 중에 무슨 함수가 더 정확한지 고민할 것이다. 이때 사용하는것이 빅-오 표기법 이다. 가장 비중이 큰 부분만 고려하자.

위의 함수 $n^2+2n+1$ 기준으로 만약 n의 값이 많아질 수 록 +1은 계산 과정에서 그리 큰 비중을 차지 하진 않는다. 그러므로 +1은 제외 하겠다. 

$n^2+2n$ 남은 함수를 기준으로 비중을 계산해야하는데 밑에 표를 보면 이해하기 쉬울 것이다.

| n  | $n^2$ | $2n$ | T(n) | $n^2$의 비율 |
| -- | ----- | ---- | ---- | ------------ |
| 100 | 10,000 | 200 | 10,200 | 98.04% |
| 1,000  | 1,000,000 | 2,000 | 1,002,000| 99.80% |
| 10,000 | 100,000,000 | 20,000 | 100,020,000 | 99.98% |

이 표에서도 나오듯이 $n^2$의 비율이 월등이 높다는 것을 알 수 있다. 따라서 $n^2+2n+1$ 이 함수에서 $2n+1$의 비중이 크지 않으니 $n^2$만 고려하면 된다. 

이를 빅오 표기법으로 $O(n) = n^2$ 표시 할 수 있다. 그렇다면 O(n)을 구할 때마다 저걸 일일히 계산해야 하나? 당연히 아니다. 만약 함수가 다항식일 경우 **최고차항의 차수**만 고려하면 된다.

| T(n) | O(n) |
| ---- | ---- |
| $n^2+2n+9$ | $n^2$ |
| $5n^3+n^2+n$ | $n^3$ |
